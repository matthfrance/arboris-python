<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'>
<title>Coverage for /System/Library/Frameworks/Python.framework/Versions/2.6/Extras/lib/python/numpy/lib/arraysetops</title>
<link rel='stylesheet' href='style.css' type='text/css'>
<script type='text/javascript' src='jquery-1.3.2.min.js'></script>
<script type='text/javascript'>
function toggle_lines(btn, cls) {
    var btn = $(btn);
    var hide = "hide_"+cls;
    if (btn.hasClass(hide)) {
        $("#source ."+cls).removeClass(hide);
        btn.removeClass(hide);
    }
    else {
        $("#source ."+cls).addClass(hide);
        btn.addClass(hide);
    }
}
</script>
</head>
<body>
<div id='header'>
    <div class='content'>
        <h1>Coverage for <b>/System/Library/Frameworks/Python.framework/Versions/2.6/Extras/lib/python/numpy/lib/arraysetops</b> :
            <span class='pc_cov'>14%</span>
        </h1>
        <h2 class='stats'>
            79 statements
            <span class='run hide_run' onclick='toggle_lines(this, "run")'>11 run</span>
            <span class='exc' onclick='toggle_lines(this, "exc")'>0 excluded</span>
            <span class='mis' onclick='toggle_lines(this, "mis")'>68 missing</span>
            
        </h2>
    </div>
</div>

<div id='source'>
<table cellspacing='0' cellpadding='0'>
<tr>
<td class='linenos' valign='top'>
<p class='pln'>1</p>
<p class='pln'>2</p>
<p class='pln'>3</p>
<p class='pln'>4</p>
<p class='pln'>5</p>
<p class='pln'>6</p>
<p class='pln'>7</p>
<p class='pln'>8</p>
<p class='pln'>9</p>
<p class='pln'>10</p>
<p class='pln'>11</p>
<p class='pln'>12</p>
<p class='pln'>13</p>
<p class='pln'>14</p>
<p class='pln'>15</p>
<p class='pln'>16</p>
<p class='pln'>17</p>
<p class='pln'>18</p>
<p class='pln'>19</p>
<p class='pln'>20</p>
<p class='pln'>21</p>
<p class='pln'>22</p>
<p class='pln'>23</p>
<p class='pln'>24</p>
<p class='pln'>25</p>
<p class='pln'>26</p>
<p class='pln'>27</p>
<p class='pln'>28</p>
<p class='pln'>29</p>
<p class='pln'>30</p>
<p class='pln'>31</p>
<p class='pln'>32</p>
<p class='pln'>33</p>
<p class='pln'>34</p>
<p class='stm run hide_run'>35</p>
<p class='pln'>36</p>
<p class='pln'>37</p>
<p class='stm run hide_run'>38</p>
<p class='stm run hide_run'>39</p>
<p class='pln'>40</p>
<p class='stm run hide_run'>41</p>
<p class='pln'>42</p>
<p class='pln'>43</p>
<p class='pln'>44</p>
<p class='pln'>45</p>
<p class='pln'>46</p>
<p class='pln'>47</p>
<p class='pln'>48</p>
<p class='pln'>49</p>
<p class='pln'>50</p>
<p class='pln'>51</p>
<p class='pln'>52</p>
<p class='pln'>53</p>
<p class='pln'>54</p>
<p class='pln'>55</p>
<p class='pln'>56</p>
<p class='pln'>57</p>
<p class='pln'>58</p>
<p class='pln'>59</p>
<p class='pln'>60</p>
<p class='pln'>61</p>
<p class='stm mis'>62</p>
<p class='stm mis'>63</p>
<p class='stm mis'>64</p>
<p class='stm mis'>65</p>
<p class='stm mis'>66</p>
<p class='stm mis'>67</p>
<p class='stm mis'>68</p>
<p class='pln'>69</p>
<p class='stm mis'>70</p>
<p class='pln'>71</p>
<p class='pln'>72</p>
<p class='stm mis'>73</p>
<p class='pln'>74</p>
<p class='stm mis'>75</p>
<p class='pln'>76</p>
<p class='stm run hide_run'>77</p>
<p class='pln'>78</p>
<p class='pln'>79</p>
<p class='pln'>80</p>
<p class='pln'>81</p>
<p class='pln'>82</p>
<p class='pln'>83</p>
<p class='pln'>84</p>
<p class='pln'>85</p>
<p class='pln'>86</p>
<p class='pln'>87</p>
<p class='pln'>88</p>
<p class='pln'>89</p>
<p class='pln'>90</p>
<p class='pln'>91</p>
<p class='pln'>92</p>
<p class='pln'>93</p>
<p class='pln'>94</p>
<p class='pln'>95</p>
<p class='pln'>96</p>
<p class='pln'>97</p>
<p class='pln'>98</p>
<p class='pln'>99</p>
<p class='pln'>100</p>
<p class='pln'>101</p>
<p class='pln'>102</p>
<p class='pln'>103</p>
<p class='pln'>104</p>
<p class='pln'>105</p>
<p class='pln'>106</p>
<p class='pln'>107</p>
<p class='pln'>108</p>
<p class='pln'>109</p>
<p class='pln'>110</p>
<p class='pln'>111</p>
<p class='pln'>112</p>
<p class='pln'>113</p>
<p class='pln'>114</p>
<p class='pln'>115</p>
<p class='pln'>116</p>
<p class='pln'>117</p>
<p class='pln'>118</p>
<p class='pln'>119</p>
<p class='pln'>120</p>
<p class='pln'>121</p>
<p class='pln'>122</p>
<p class='pln'>123</p>
<p class='pln'>124</p>
<p class='pln'>125</p>
<p class='pln'>126</p>
<p class='pln'>127</p>
<p class='pln'>128</p>
<p class='stm mis'>129</p>
<p class='stm mis'>130</p>
<p class='stm mis'>131</p>
<p class='pln'>132</p>
<p class='pln'>133</p>
<p class='pln'>134</p>
<p class='pln'>135</p>
<p class='stm mis'>136</p>
<p class='stm mis'>137</p>
<p class='stm mis'>138</p>
<p class='stm mis'>139</p>
<p class='stm mis'>140</p>
<p class='stm mis'>141</p>
<p class='pln'>142</p>
<p class='stm mis'>143</p>
<p class='pln'>144</p>
<p class='stm mis'>145</p>
<p class='stm mis'>146</p>
<p class='stm mis'>147</p>
<p class='stm mis'>148</p>
<p class='stm mis'>149</p>
<p class='stm mis'>150</p>
<p class='stm mis'>151</p>
<p class='stm mis'>152</p>
<p class='stm mis'>153</p>
<p class='pln'>154</p>
<p class='stm mis'>155</p>
<p class='pln'>156</p>
<p class='stm mis'>157</p>
<p class='pln'>158</p>
<p class='pln'>159</p>
<p class='stm mis'>160</p>
<p class='stm mis'>161</p>
<p class='stm mis'>162</p>
<p class='pln'>163</p>
<p class='stm run hide_run'>164</p>
<p class='pln'>165</p>
<p class='pln'>166</p>
<p class='pln'>167</p>
<p class='pln'>168</p>
<p class='pln'>169</p>
<p class='pln'>170</p>
<p class='pln'>171</p>
<p class='pln'>172</p>
<p class='pln'>173</p>
<p class='pln'>174</p>
<p class='pln'>175</p>
<p class='pln'>176</p>
<p class='pln'>177</p>
<p class='pln'>178</p>
<p class='pln'>179</p>
<p class='pln'>180</p>
<p class='pln'>181</p>
<p class='pln'>182</p>
<p class='pln'>183</p>
<p class='pln'>184</p>
<p class='pln'>185</p>
<p class='pln'>186</p>
<p class='pln'>187</p>
<p class='pln'>188</p>
<p class='pln'>189</p>
<p class='stm mis'>190</p>
<p class='stm mis'>191</p>
<p class='stm mis'>192</p>
<p class='pln'>193</p>
<p class='stm run hide_run'>194</p>
<p class='pln'>195</p>
<p class='pln'>196</p>
<p class='pln'>197</p>
<p class='pln'>198</p>
<p class='pln'>199</p>
<p class='pln'>200</p>
<p class='pln'>201</p>
<p class='pln'>202</p>
<p class='pln'>203</p>
<p class='pln'>204</p>
<p class='pln'>205</p>
<p class='pln'>206</p>
<p class='pln'>207</p>
<p class='pln'>208</p>
<p class='pln'>209</p>
<p class='pln'>210</p>
<p class='pln'>211</p>
<p class='pln'>212</p>
<p class='pln'>213</p>
<p class='pln'>214</p>
<p class='pln'>215</p>
<p class='pln'>216</p>
<p class='pln'>217</p>
<p class='pln'>218</p>
<p class='pln'>219</p>
<p class='pln'>220</p>
<p class='stm mis'>221</p>
<p class='stm mis'>222</p>
<p class='stm mis'>223</p>
<p class='pln'>224</p>
<p class='stm run hide_run'>225</p>
<p class='pln'>226</p>
<p class='pln'>227</p>
<p class='pln'>228</p>
<p class='pln'>229</p>
<p class='pln'>230</p>
<p class='pln'>231</p>
<p class='pln'>232</p>
<p class='pln'>233</p>
<p class='pln'>234</p>
<p class='pln'>235</p>
<p class='pln'>236</p>
<p class='pln'>237</p>
<p class='pln'>238</p>
<p class='pln'>239</p>
<p class='pln'>240</p>
<p class='pln'>241</p>
<p class='pln'>242</p>
<p class='pln'>243</p>
<p class='pln'>244</p>
<p class='pln'>245</p>
<p class='pln'>246</p>
<p class='pln'>247</p>
<p class='pln'>248</p>
<p class='pln'>249</p>
<p class='stm mis'>250</p>
<p class='stm mis'>251</p>
<p class='stm mis'>252</p>
<p class='pln'>253</p>
<p class='stm mis'>254</p>
<p class='pln'>255</p>
<p class='stm mis'>256</p>
<p class='pln'>257</p>
<p class='stm mis'>258</p>
<p class='stm mis'>259</p>
<p class='pln'>260</p>
<p class='stm run hide_run'>261</p>
<p class='pln'>262</p>
<p class='pln'>263</p>
<p class='pln'>264</p>
<p class='pln'>265</p>
<p class='pln'>266</p>
<p class='pln'>267</p>
<p class='pln'>268</p>
<p class='pln'>269</p>
<p class='pln'>270</p>
<p class='pln'>271</p>
<p class='pln'>272</p>
<p class='pln'>273</p>
<p class='pln'>274</p>
<p class='pln'>275</p>
<p class='pln'>276</p>
<p class='pln'>277</p>
<p class='pln'>278</p>
<p class='pln'>279</p>
<p class='pln'>280</p>
<p class='pln'>281</p>
<p class='pln'>282</p>
<p class='pln'>283</p>
<p class='pln'>284</p>
<p class='pln'>285</p>
<p class='pln'>286</p>
<p class='pln'>287</p>
<p class='pln'>288</p>
<p class='stm mis'>289</p>
<p class='stm mis'>290</p>
<p class='stm mis'>291</p>
<p class='stm mis'>292</p>
<p class='stm mis'>293</p>
<p class='stm mis'>294</p>
<p class='pln'>295</p>
<p class='pln'>296</p>
<p class='pln'>297</p>
<p class='pln'>298</p>
<p class='stm mis'>299</p>
<p class='stm mis'>300</p>
<p class='stm mis'>301</p>
<p class='pln'>302</p>
<p class='stm mis'>303</p>
<p class='stm mis'>304</p>
<p class='stm mis'>305</p>
<p class='stm mis'>306</p>
<p class='stm mis'>307</p>
<p class='pln'>308</p>
<p class='stm mis'>309</p>
<p class='pln'>310</p>
<p class='stm mis'>311</p>
<p class='pln'>312</p>
<p class='stm run hide_run'>313</p>
<p class='pln'>314</p>
<p class='pln'>315</p>
<p class='pln'>316</p>
<p class='pln'>317</p>
<p class='pln'>318</p>
<p class='pln'>319</p>
<p class='pln'>320</p>
<p class='pln'>321</p>
<p class='pln'>322</p>
<p class='pln'>323</p>
<p class='pln'>324</p>
<p class='pln'>325</p>
<p class='pln'>326</p>
<p class='pln'>327</p>
<p class='pln'>328</p>
<p class='pln'>329</p>
<p class='pln'>330</p>
<p class='pln'>331</p>
<p class='pln'>332</p>
<p class='pln'>333</p>
<p class='pln'>334</p>
<p class='pln'>335</p>
<p class='pln'>336</p>
<p class='pln'>337</p>
<p class='stm mis'>338</p>
<p class='pln'>339</p>
<p class='stm run hide_run'>340</p>
<p class='pln'>341</p>
<p class='pln'>342</p>
<p class='pln'>343</p>
<p class='pln'>344</p>
<p class='pln'>345</p>
<p class='pln'>346</p>
<p class='pln'>347</p>
<p class='pln'>348</p>
<p class='pln'>349</p>
<p class='pln'>350</p>
<p class='pln'>351</p>
<p class='pln'>352</p>
<p class='pln'>353</p>
<p class='pln'>354</p>
<p class='pln'>355</p>
<p class='pln'>356</p>
<p class='pln'>357</p>
<p class='pln'>358</p>
<p class='pln'>359</p>
<p class='pln'>360</p>
<p class='pln'>361</p>
<p class='pln'>362</p>
<p class='pln'>363</p>
<p class='pln'>364</p>
<p class='stm mis'>365</p>
<p class='stm mis'>366</p>
<p class='stm mis'>367</p>
<p class='pln'>368</p>
<p class='stm mis'>369</p>
    
</td>
<td class='text' valign='top'>
<p class='pln'><span class='str'>&quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>Set operations for 1D numeric arrays based on sorting.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>:Contains:</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; ediff1d,</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; unique1d,</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; intersect1d,</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; intersect1d_nu,</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; setxor1d,</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; setmember1d,</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; union1d,</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; setdiff1d</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>:Notes:</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>All functions work best with integer numerical arrays on input (e.g. indices).</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>For floating point arrays, innacurate results may appear due to usual round-off</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>and floating point comparison issues.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>Except unique1d, union1d and intersect1d_nu, all functions expect inputs with</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>unique elements. Speed could be gained in some operations by an implementaion of</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>sort(), that can provide directly the permutation vectors, avoiding thus calls</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>to argsort().</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>Run _test_unique1d_speed() to compare performance of numpy.unique1d() and</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>numpy.unique() - it should be the same.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>To do: Optionally return indices analogously to unique1d for all functions.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>created:&nbsp; &nbsp; &nbsp;&nbsp; 01.11.2005</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>last revision: 07.01.2007</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>:Author: Robert Cimrman</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='stm run hide_run'><span class='nam'>__all__</span> <span class='op'>=</span> <span class='op'>[</span><span class='str'>&#39;ediff1d&#39;</span><span class='op'>,</span> <span class='str'>&#39;unique1d&#39;</span><span class='op'>,</span> <span class='str'>&#39;intersect1d&#39;</span><span class='op'>,</span> <span class='str'>&#39;intersect1d_nu&#39;</span><span class='op'>,</span> <span class='str'>&#39;setxor1d&#39;</span><span class='op'>,</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class='str'>&#39;setmember1d&#39;</span><span class='op'>,</span> <span class='str'>&#39;union1d&#39;</span><span class='op'>,</span> <span class='str'>&#39;setdiff1d&#39;</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='stm run hide_run'><span class='key'>import</span> <span class='nam'>time</span><span class='strut'>&nbsp;</span></p>
<p class='stm run hide_run'><span class='key'>import</span> <span class='nam'>numpy</span> <span class='key'>as</span> <span class='nam'>np</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='stm run hide_run'><span class='key'>def</span> <span class='nam'>ediff1d</span><span class='op'>(</span><span class='nam'>ary</span><span class='op'>,</span> <span class='nam'>to_end</span><span class='op'>=</span><span class='nam'>None</span><span class='op'>,</span> <span class='nam'>to_begin</span><span class='op'>=</span><span class='nam'>None</span><span class='op'>)</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; <span class='str'>&quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; The differences between consecutive elements of an array.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Parameters</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ----------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ary : array</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; This array will be flattened before the difference is taken.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; to_end : number, optional</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; If provided, this number will be tacked onto the end of the returned</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; differences.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; to_begin : number, optional</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; If provided, this number will be taked onto the beginning of the</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; returned differences.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Returns</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; -------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ed : array</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; The differences. Loosely, this will be (ary[1:] - ary[:-1]).</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>ary</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>asarray</span><span class='op'>(</span><span class='nam'>ary</span><span class='op'>)</span><span class='op'>.</span><span class='nam'>flat</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>ed</span> <span class='op'>=</span> <span class='nam'>ary</span><span class='op'>[</span><span class='num'>1</span><span class='op'>:</span><span class='op'>]</span> <span class='op'>-</span> <span class='nam'>ary</span><span class='op'>[</span><span class='op'>:</span><span class='op'>-</span><span class='num'>1</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>arrays</span> <span class='op'>=</span> <span class='op'>[</span><span class='nam'>ed</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='key'>if</span> <span class='nam'>to_begin</span> <span class='key'>is</span> <span class='key'>not</span> <span class='nam'>None</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='nam'>arrays</span><span class='op'>.</span><span class='nam'>insert</span><span class='op'>(</span><span class='num'>0</span><span class='op'>,</span> <span class='nam'>to_begin</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='key'>if</span> <span class='nam'>to_end</span> <span class='key'>is</span> <span class='key'>not</span> <span class='nam'>None</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='nam'>arrays</span><span class='op'>.</span><span class='nam'>append</span><span class='op'>(</span><span class='nam'>to_end</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='key'>if</span> <span class='nam'>len</span><span class='op'>(</span><span class='nam'>arrays</span><span class='op'>)</span> <span class='op'>!=</span> <span class='num'>1</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='com'># We&#39;ll save ourselves a copy of a potentially large array in the common</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='com'># case where neither to_begin or to_end was given.</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='nam'>ed</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>hstack</span><span class='op'>(</span><span class='nam'>arrays</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='key'>return</span> <span class='nam'>ed</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='stm run hide_run'><span class='key'>def</span> <span class='nam'>unique1d</span><span class='op'>(</span><span class='nam'>ar1</span><span class='op'>,</span> <span class='nam'>return_index</span><span class='op'>=</span><span class='nam'>False</span><span class='op'>,</span> <span class='nam'>return_inverse</span><span class='op'>=</span><span class='nam'>False</span><span class='op'>)</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; <span class='str'>&quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Find the unique elements of an array.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Parameters</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ----------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ar1 : array_like</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; This array will be flattened if it is not already 1-D.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; return_index : bool, optional</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; If True, also return the indices against `ar1` that result in the</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; unique array.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; return_inverse : bool, optional</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; If True, also return the indices against the unique array that</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; result in `ar1`.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Returns</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; -------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; unique : ndarray</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; The unique values.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; unique_indices : ndarray, optional</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; The indices of the unique values. Only provided if `return_index` is</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; True.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; unique_inverse : ndarray, optional</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; The indices to reconstruct the original array. Only provided if</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; `return_inverse` is True.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; See Also</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; --------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; numpy.lib.arraysetops : Module with a number of other functions</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for performing set operations on arrays.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Examples</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; --------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &gt;&gt;&gt; np.unique1d([1, 1, 2, 2, 3, 3])</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; array([1, 2, 3])</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &gt;&gt;&gt; a = np.array([[1, 1], [2, 3]])</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &gt;&gt;&gt; np.unique1d(a)</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; array([1, 2, 3])</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Reconstruct the input from unique values:</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &gt;&gt;&gt; np.unique1d([1,2,6,4,2,3,2], return_index=True)</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &gt;&gt;&gt; x = [1,2,6,4,2,3,2]</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &gt;&gt;&gt; u, i = np.unique1d(x, return_inverse=True)</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &gt;&gt;&gt; u</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; array([1, 2, 3, 4, 6])</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &gt;&gt;&gt; i</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; array([0, 1, 4, 3, 1, 2, 1])</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &gt;&gt;&gt; [u[p] for p in i]</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; [1, 2, 6, 4, 2, 3, 2]</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='key'>if</span> <span class='nam'>return_index</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>import</span> <span class='nam'>warnings</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='nam'>warnings</span><span class='op'>.</span><span class='nam'>warn</span><span class='op'>(</span><span class='str'>&quot;The order of the output arguments for &quot;</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class='str'>&quot;`return_index` has changed.&nbsp; Before, &quot;</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class='str'>&quot;the output was (indices, unique_arr), but &quot;</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class='str'>&quot;has now been reversed to be more consistent.&quot;</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>ar</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>asarray</span><span class='op'>(</span><span class='nam'>ar1</span><span class='op'>)</span><span class='op'>.</span><span class='nam'>flatten</span><span class='op'>(</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='key'>if</span> <span class='nam'>ar</span><span class='op'>.</span><span class='nam'>size</span> <span class='op'>==</span> <span class='num'>0</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>if</span> <span class='nam'>return_inverse</span> <span class='key'>and</span> <span class='nam'>return_index</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>return</span> <span class='nam'>ar</span><span class='op'>,</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>empty</span><span class='op'>(</span><span class='num'>0</span><span class='op'>,</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>bool</span><span class='op'>)</span><span class='op'>,</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>empty</span><span class='op'>(</span><span class='num'>0</span><span class='op'>,</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>bool</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>elif</span> <span class='nam'>return_inverse</span> <span class='key'>or</span> <span class='nam'>return_index</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>return</span> <span class='nam'>ar</span><span class='op'>,</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>empty</span><span class='op'>(</span><span class='num'>0</span><span class='op'>,</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>bool</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>else</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>return</span> <span class='nam'>ar</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='key'>if</span> <span class='nam'>return_inverse</span> <span class='key'>or</span> <span class='nam'>return_index</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='nam'>perm</span> <span class='op'>=</span> <span class='nam'>ar</span><span class='op'>.</span><span class='nam'>argsort</span><span class='op'>(</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='nam'>aux</span> <span class='op'>=</span> <span class='nam'>ar</span><span class='op'>[</span><span class='nam'>perm</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='nam'>flag</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>concatenate</span><span class='op'>(</span><span class='op'>(</span><span class='op'>[</span><span class='nam'>True</span><span class='op'>]</span><span class='op'>,</span> <span class='nam'>aux</span><span class='op'>[</span><span class='num'>1</span><span class='op'>:</span><span class='op'>]</span> <span class='op'>!=</span> <span class='nam'>aux</span><span class='op'>[</span><span class='op'>:</span><span class='op'>-</span><span class='num'>1</span><span class='op'>]</span><span class='op'>)</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>if</span> <span class='nam'>return_inverse</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class='nam'>iflag</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>cumsum</span><span class='op'>(</span><span class='nam'>flag</span><span class='op'>)</span> <span class='op'>-</span> <span class='num'>1</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class='nam'>iperm</span> <span class='op'>=</span> <span class='nam'>perm</span><span class='op'>.</span><span class='nam'>argsort</span><span class='op'>(</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>if</span> <span class='nam'>return_index</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>return</span> <span class='nam'>aux</span><span class='op'>[</span><span class='nam'>flag</span><span class='op'>]</span><span class='op'>,</span> <span class='nam'>perm</span><span class='op'>[</span><span class='nam'>flag</span><span class='op'>]</span><span class='op'>,</span> <span class='nam'>iflag</span><span class='op'>[</span><span class='nam'>iperm</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>else</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>return</span> <span class='nam'>aux</span><span class='op'>[</span><span class='nam'>flag</span><span class='op'>]</span><span class='op'>,</span> <span class='nam'>iflag</span><span class='op'>[</span><span class='nam'>iperm</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>else</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>return</span> <span class='nam'>aux</span><span class='op'>[</span><span class='nam'>flag</span><span class='op'>]</span><span class='op'>,</span> <span class='nam'>perm</span><span class='op'>[</span><span class='nam'>flag</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; <span class='key'>else</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='nam'>ar</span><span class='op'>.</span><span class='nam'>sort</span><span class='op'>(</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='nam'>flag</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>concatenate</span><span class='op'>(</span><span class='op'>(</span><span class='op'>[</span><span class='nam'>True</span><span class='op'>]</span><span class='op'>,</span> <span class='nam'>ar</span><span class='op'>[</span><span class='num'>1</span><span class='op'>:</span><span class='op'>]</span> <span class='op'>!=</span> <span class='nam'>ar</span><span class='op'>[</span><span class='op'>:</span><span class='op'>-</span><span class='num'>1</span><span class='op'>]</span><span class='op'>)</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>return</span> <span class='nam'>ar</span><span class='op'>[</span><span class='nam'>flag</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='stm run hide_run'><span class='key'>def</span> <span class='nam'>intersect1d</span><span class='op'>(</span><span class='nam'>ar1</span><span class='op'>,</span> <span class='nam'>ar2</span><span class='op'>)</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; <span class='str'>&quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Intersection returning repeated or unique elements common to both arrays.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Parameters</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ----------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ar1,ar2 : array_like</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; Input arrays.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Returns</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; -------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; out : ndarray, shape(N,)</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; Sorted 1D array of common elements with repeating elements.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; See Also</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; --------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; intersect1d_nu : Returns only unique common elements.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; numpy.lib.arraysetops : Module with a number of other functions for</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; performing set operations on arrays.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Examples</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; --------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &gt;&gt;&gt; np.intersect1d([1,3,3],[3,1,1])</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; array([1, 1, 3, 3])</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>aux</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>concatenate</span><span class='op'>(</span><span class='op'>(</span><span class='nam'>ar1</span><span class='op'>,</span><span class='nam'>ar2</span><span class='op'>)</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>aux</span><span class='op'>.</span><span class='nam'>sort</span><span class='op'>(</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='key'>return</span> <span class='nam'>aux</span><span class='op'>[</span><span class='nam'>aux</span><span class='op'>[</span><span class='num'>1</span><span class='op'>:</span><span class='op'>]</span> <span class='op'>==</span> <span class='nam'>aux</span><span class='op'>[</span><span class='op'>:</span><span class='op'>-</span><span class='num'>1</span><span class='op'>]</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='stm run hide_run'><span class='key'>def</span> <span class='nam'>intersect1d_nu</span><span class='op'>(</span><span class='nam'>ar1</span><span class='op'>,</span> <span class='nam'>ar2</span><span class='op'>)</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; <span class='str'>&quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Intersection returning unique elements common to both arrays.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Parameters</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ----------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ar1,ar2 : array_like</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; Input arrays.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Returns</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; -------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; out : ndarray, shape(N,)</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; Sorted 1D array of common and unique elements.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; See Also</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; --------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; intersect1d : Returns repeated or unique common elements.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; numpy.lib.arraysetops : Module with a number of other functions for</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; performing set operations on arrays.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Examples</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; --------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &gt;&gt;&gt; np.intersect1d_nu([1,3,3],[3,1,1])</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; array([1, 3])</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; <span class='com'># Might be faster than unique1d( intersect1d( ar1, ar2 ) )?</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>aux</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>concatenate</span><span class='op'>(</span><span class='op'>(</span><span class='nam'>unique1d</span><span class='op'>(</span><span class='nam'>ar1</span><span class='op'>)</span><span class='op'>,</span> <span class='nam'>unique1d</span><span class='op'>(</span><span class='nam'>ar2</span><span class='op'>)</span><span class='op'>)</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>aux</span><span class='op'>.</span><span class='nam'>sort</span><span class='op'>(</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='key'>return</span> <span class='nam'>aux</span><span class='op'>[</span><span class='nam'>aux</span><span class='op'>[</span><span class='num'>1</span><span class='op'>:</span><span class='op'>]</span> <span class='op'>==</span> <span class='nam'>aux</span><span class='op'>[</span><span class='op'>:</span><span class='op'>-</span><span class='num'>1</span><span class='op'>]</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='stm run hide_run'><span class='key'>def</span> <span class='nam'>setxor1d</span><span class='op'>(</span><span class='nam'>ar1</span><span class='op'>,</span> <span class='nam'>ar2</span><span class='op'>)</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; <span class='str'>&quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Set exclusive-or of 1D arrays with unique elements.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Use unique1d() to generate arrays with only unique elements to use as</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; inputs to this function.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Parameters</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ----------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ar1 : array_like</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; Input array.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ar2 : array_like</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; Input array.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Returns</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; -------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; xor : ndarray</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; The values that are only in one, but not both, of the input arrays.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; See Also</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; --------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; numpy.lib.arraysetops : Module with a number of other functions for</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; performing set operations on arrays.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>aux</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>concatenate</span><span class='op'>(</span><span class='op'>(</span><span class='nam'>ar1</span><span class='op'>,</span> <span class='nam'>ar2</span><span class='op'>)</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='key'>if</span> <span class='nam'>aux</span><span class='op'>.</span><span class='nam'>size</span> <span class='op'>==</span> <span class='num'>0</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>return</span> <span class='nam'>aux</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>aux</span><span class='op'>.</span><span class='nam'>sort</span><span class='op'>(</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='com'>#&nbsp; &nbsp; flag = ediff1d( aux, to_end = 1, to_begin = 1 ) == 0</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>flag</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>concatenate</span><span class='op'>(</span> <span class='op'>(</span><span class='op'>[</span><span class='nam'>True</span><span class='op'>]</span><span class='op'>,</span> <span class='nam'>aux</span><span class='op'>[</span><span class='num'>1</span><span class='op'>:</span><span class='op'>]</span> <span class='op'>!=</span> <span class='nam'>aux</span><span class='op'>[</span><span class='op'>:</span><span class='op'>-</span><span class='num'>1</span><span class='op'>]</span><span class='op'>,</span> <span class='op'>[</span><span class='nam'>True</span><span class='op'>]</span> <span class='op'>)</span> <span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='com'>#&nbsp; &nbsp; flag2 = ediff1d( flag ) == 0</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>flag2</span> <span class='op'>=</span> <span class='nam'>flag</span><span class='op'>[</span><span class='num'>1</span><span class='op'>:</span><span class='op'>]</span> <span class='op'>==</span> <span class='nam'>flag</span><span class='op'>[</span><span class='op'>:</span><span class='op'>-</span><span class='num'>1</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='key'>return</span> <span class='nam'>aux</span><span class='op'>[</span><span class='nam'>flag2</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='stm run hide_run'><span class='key'>def</span> <span class='nam'>setmember1d</span><span class='op'>(</span><span class='nam'>ar1</span><span class='op'>,</span> <span class='nam'>ar2</span><span class='op'>)</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; <span class='str'>&quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Return a boolean array set True where first element is in second array.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Boolean array is the shape of `ar1` containing True where the elements</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; of `ar1` are in `ar2` and False otherwise.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Use unique1d() to generate arrays with only unique elements to use as</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; inputs to this function.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Parameters</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ----------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ar1 : array_like</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; Input array.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ar2 : array_like</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; Input array.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Returns</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; -------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; mask : ndarray, bool</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; The values `ar1[mask]` are in `ar2`.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; See Also</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; --------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; numpy.lib.arraysetops : Module with a number of other functions for</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; performing set operations on arrays.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>ar1</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>asarray</span><span class='op'>(</span> <span class='nam'>ar1</span> <span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>ar2</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>asarray</span><span class='op'>(</span> <span class='nam'>ar2</span> <span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>ar</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>concatenate</span><span class='op'>(</span> <span class='op'>(</span><span class='nam'>ar1</span><span class='op'>,</span> <span class='nam'>ar2</span> <span class='op'>)</span> <span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>b1</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>zeros</span><span class='op'>(</span> <span class='nam'>ar1</span><span class='op'>.</span><span class='nam'>shape</span><span class='op'>,</span> <span class='nam'>dtype</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>int8</span> <span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>b2</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>ones</span><span class='op'>(</span> <span class='nam'>ar2</span><span class='op'>.</span><span class='nam'>shape</span><span class='op'>,</span> <span class='nam'>dtype</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>int8</span> <span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>tt</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>concatenate</span><span class='op'>(</span> <span class='op'>(</span><span class='nam'>b1</span><span class='op'>,</span> <span class='nam'>b2</span><span class='op'>)</span> <span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; <span class='com'># We need this to be a stable sort, so always use &#39;mergesort&#39; here. The</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; <span class='com'># values from the first array should always come before the values from the</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; <span class='com'># second array.</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>perm</span> <span class='op'>=</span> <span class='nam'>ar</span><span class='op'>.</span><span class='nam'>argsort</span><span class='op'>(</span><span class='nam'>kind</span><span class='op'>=</span><span class='str'>&#39;mergesort&#39;</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>aux</span> <span class='op'>=</span> <span class='nam'>ar</span><span class='op'>[</span><span class='nam'>perm</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>aux2</span> <span class='op'>=</span> <span class='nam'>tt</span><span class='op'>[</span><span class='nam'>perm</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='com'>#&nbsp; &nbsp; flag = ediff1d( aux, 1 ) == 0</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>flag</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>concatenate</span><span class='op'>(</span> <span class='op'>(</span><span class='nam'>aux</span><span class='op'>[</span><span class='num'>1</span><span class='op'>:</span><span class='op'>]</span> <span class='op'>==</span> <span class='nam'>aux</span><span class='op'>[</span><span class='op'>:</span><span class='op'>-</span><span class='num'>1</span><span class='op'>]</span><span class='op'>,</span> <span class='op'>[</span><span class='nam'>False</span><span class='op'>]</span> <span class='op'>)</span> <span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>ii</span> <span class='op'>=</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>where</span><span class='op'>(</span> <span class='nam'>flag</span> <span class='op'>*</span> <span class='nam'>aux2</span> <span class='op'>)</span><span class='op'>[</span><span class='num'>0</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>aux</span> <span class='op'>=</span> <span class='nam'>perm</span><span class='op'>[</span><span class='nam'>ii</span><span class='op'>+</span><span class='num'>1</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>perm</span><span class='op'>[</span><span class='nam'>ii</span><span class='op'>+</span><span class='num'>1</span><span class='op'>]</span> <span class='op'>=</span> <span class='nam'>perm</span><span class='op'>[</span><span class='nam'>ii</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>perm</span><span class='op'>[</span><span class='nam'>ii</span><span class='op'>]</span> <span class='op'>=</span> <span class='nam'>aux</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>indx</span> <span class='op'>=</span> <span class='nam'>perm</span><span class='op'>.</span><span class='nam'>argsort</span><span class='op'>(</span><span class='nam'>kind</span><span class='op'>=</span><span class='str'>&#39;mergesort&#39;</span><span class='op'>)</span><span class='op'>[</span><span class='op'>:</span><span class='nam'>len</span><span class='op'>(</span> <span class='nam'>ar1</span> <span class='op'>)</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='key'>return</span> <span class='nam'>flag</span><span class='op'>[</span><span class='nam'>indx</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='stm run hide_run'><span class='key'>def</span> <span class='nam'>union1d</span><span class='op'>(</span><span class='nam'>ar1</span><span class='op'>,</span> <span class='nam'>ar2</span><span class='op'>)</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; <span class='str'>&quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Union of 1D arrays with unique elements.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Use unique1d() to generate arrays with only unique elements to use as</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; inputs to this function.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Parameters</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ----------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ar1 : array_like, shape(M,)</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; Input array.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ar2 : array_like, shape(N,)</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; Input array.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Returns</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; -------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; union : ndarray</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; Unique union of input arrays.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; See also</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; --------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; numpy.lib.arraysetops : Module with a number of other functions for</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; performing set operations on arrays.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='key'>return</span> <span class='nam'>unique1d</span><span class='op'>(</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>concatenate</span><span class='op'>(</span> <span class='op'>(</span><span class='nam'>ar1</span><span class='op'>,</span> <span class='nam'>ar2</span><span class='op'>)</span> <span class='op'>)</span> <span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='stm run hide_run'><span class='key'>def</span> <span class='nam'>setdiff1d</span><span class='op'>(</span><span class='nam'>ar1</span><span class='op'>,</span> <span class='nam'>ar2</span><span class='op'>)</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; <span class='str'>&quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Set difference of 1D arrays with unique elements.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Use unique1d() to generate arrays with only unique elements to use as</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; inputs to this function.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Parameters</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ----------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ar1 : array_like</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; Input array.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; ar2 : array_like</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; Input comparison array.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; Returns</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; -------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; difference : ndarray</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; The values in ar1 that are not in ar2.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; See Also</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; --------</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; numpy.lib.arraysetops : Module with a number of other functions for</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; performing set operations on arrays.</span><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='strut'>&nbsp;</span></p>
<p class='pln'><span class='str'>&nbsp; &nbsp; &quot;&quot;&quot;</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='nam'>aux</span> <span class='op'>=</span> <span class='nam'>setmember1d</span><span class='op'>(</span><span class='nam'>ar1</span><span class='op'>,</span><span class='nam'>ar2</span><span class='op'>)</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; <span class='key'>if</span> <span class='nam'>aux</span><span class='op'>.</span><span class='nam'>size</span> <span class='op'>==</span> <span class='num'>0</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>return</span> <span class='nam'>aux</span><span class='strut'>&nbsp;</span></p>
<p class='pln'>&nbsp; &nbsp; <span class='key'>else</span><span class='op'>:</span><span class='strut'>&nbsp;</span></p>
<p class='stm mis'>&nbsp; &nbsp; &nbsp; &nbsp; <span class='key'>return</span> <span class='nam'>np</span><span class='op'>.</span><span class='nam'>asarray</span><span class='op'>(</span><span class='nam'>ar1</span><span class='op'>)</span><span class='op'>[</span><span class='nam'>aux</span> <span class='op'>==</span> <span class='num'>0</span><span class='op'>]</span><span class='strut'>&nbsp;</span></p>
    
</td>
</tr>
</table>
</div>

</body>
</html>
